const std = @import("std");
const lc4k = @import("lc4k.zig");
const jedec = @import("jedec.zig");

const Fuse = jedec.Fuse;
const JedecData = jedec.JedecData;
const JedecFile = jedec.JedecFile;

const NoData = void;

pub fn getIDCode(comptime Device: type) u32 {
    return switch (Device.family) {
        .zero_power_enhanced => switch (Device.num_glbs) {
            2 => 0x01806043,
            4 => 0x0180E043,
            8 => 0x01812043,
            else => unreachable,
        },
        .zero_power => switch (Device.num_glbs) {
            2 => 0x11804043,
            4 => 0x1180C043,
            8 => 0x11810043,
            else => unreachable,
        },
        .low_power => switch (Device.num_glbs) {
            2 => 0x01805043,
            4 => switch (Device.jedec_dimensions.height()) {
                95 => 0x01809043,
                100 => 0x0180D043,
                else => unreachable,
            },
            8 => 0x01811043,
            else => unreachable,
        },
    };
}

pub fn getBoundaryScanLength(comptime Device: type) usize {
    switch (Device.device_type) {
        .LC4064x_TQFP44, .LC4064x_TQFP48 => return 68,
        else => {}
    }
    return switch (Device.num_glbs) {
        2 => 68,
        4 => 138,
        8 => 196,
        else => unreachable,
    };
}

pub const Delay = struct {
    min_clocks: u16,
    min_ms: u16,

    pub fn init(clocks: u16, ms: u16) Delay {
        return .{ .min_clocks = clocks, .min_ms = ms };
    }
};

pub const JtagCommand = enum (u8) {
    EXTEST = 0x00,
    ISC_ADDRESS_SHIFT = 0x01,
    ISC_DATA_SHIFT = 0x02,
    ISC_ERASE = 0x03,
    ISC_PROGRAM_SECURITY = 0x09,
    ISC_DISCHARGE = 0x14,
    ISC_ENABLE = 0x15,
    IDCODE = 0x16,
    READ_USERCODE = 0x17,
    HIGHZ = 0x18,
    ISC_PROGRAM_USERCODE = 0x1A,
    SAMPLE_PRELOAD = 0x1C,
    ISC_DISABLE = 0x1E,
    CLAMP = 0x20,
    ISC_ADDRESS_INIT = 0x21,
    ISC_ERASE_DONE = 0x24,
    ISC_PROGRAM = 0x27,
    ISC_READ = 0x2A,
    PRIVATE = 0x2C,
    ISC_PROGRAM_DONE = 0x2F,
    ISC_NOOP = 0x30,
    BYPASS = 0xFF,

    pub fn getDelay(self: JtagCommand) Delay {
        return switch (self) {
            .ISC_ENABLE => Delay.init(3, 20),
            .ISC_PROGRAM, .ISC_PROGRAM_USERCODE => Delay.init(3, 13),
            .ISC_READ => Delay.init(1, 1), // N.B. this delay happens *before* the SDR transaction
            .ISC_PROGRAM_SECURITY, .ISC_ERASE_DONE, .ISC_PROGRAM_DONE => Delay.init(3, 50),
            .ISC_ERASE, .ISC_DISCHARGE, .ISC_DISABLE => Delay.init(3, 200),
            .BYPASS => Delay.init(32, 10),
            else => Delay.init(0, 0),
        };
    }
};

pub const WriteOptions = struct {
    erase: bool = true,
    verify: bool = true,
    line_ending: []const u8 = "\n",
    notes: []const u8 = "",
};

pub fn write(comptime Device: type, file: JedecFile, writer: anytype, options: WriteOptions) !void {
    const nl = options.line_ending;

    std.debug.assert(file.data.extents.eql(Device.jedec_dimensions));

    try writer.print("! {s} configuration generated by https://github.com/bcrist/Zig-LC4k{s}", .{ @tagName(Device.device_type), nl });

    if (options.notes.len > 0) {
        var iter = std.mem.split(u8, options.notes, "\n*");
        while (iter.next()) |l| {
            var line = l;
            if (std.mem.endsWith(u8, line, "\r")) {
                line = line[0..line.len - 1];
            }
            try writer.print("! {s}{s}", .{ line, nl });
        }
    }
    try writer.writeAll(nl);
    try writeState("RESET", writer, nl);
    try writer.writeAll(nl);
    try writer.print("! Row_Width\t:{}{s}", .{ Device.jedec_dimensions.width(), nl });
    try writer.print("! Address_Length\t:{}{s}", .{ Device.jedec_dimensions.height(), nl });
    try writer.print("HDR\t0;{s}", .{ nl });
    try writer.print("HIR\t0;{s}", .{ nl });
    try writer.print("TDR\t0;{s}", .{ nl });
    try writer.print("TIR\t0;{s}", .{ nl });
    try writer.print("ENDDR\tDRPAUSE;{s}", .{ nl });
    try writer.print("ENDIR\tIDLE;{s}", .{ nl });
    try writer.print("! FREQUENCY\t25.E+6 HZ;{s}", .{ nl });
    try writeState("IDLE", writer, nl);
    try writer.writeAll(nl);

    try writeCommand(.IDCODE, u32, 0xFFFFFFFF, getIDCode(Device), writer, nl);
    try writer.writeAll(nl);

    try writeCommand(.SAMPLE_PRELOAD, std.meta.Int(.unsigned, getBoundaryScanLength(Device)), 0, null, writer, nl);
    try writer.writeAll(nl);

    try writeCommand(.ISC_ENABLE, NoData, null, null, writer, nl);
    try writer.writeAll(nl);

    if (options.erase) {
        try writeCommand(.ISC_ERASE, NoData, null, null, writer, nl);
        try writeCommand(.ISC_DISCHARGE, NoData, null, null, writer, nl);
        try writer.writeAll(nl);
    }

    {
        try writeCommand(.ISC_ADDRESS_INIT, NoData, null, null, writer, nl);
        try writeCommand(.ISC_PROGRAM, NoData, null, null, writer, nl);

        var row: u16 = 0;
        while (row < Device.jedec_dimensions.height()) : (row += 1) {
            try writer.print("SDR\t{}\tTDI  (", .{ Device.jedec_dimensions.width() });
            try writeRowHex(file.data, row, writer);
            try writer.print(");{s}", .{ nl });
            try writeIdle(.ISC_PROGRAM, writer, nl);
        }
        try writer.writeAll(nl);
    }

    if (options.verify) {
        const rows = comptime Device.jedec_dimensions.height();
        const AddressShiftType = std.meta.Int(.unsigned, @intCast(rows));
        const address_shift = @as(AddressShiftType, 1) << (rows - 1);
        try writeCommand(.ISC_ADDRESS_SHIFT, AddressShiftType, address_shift, null, writer, nl);
        try writeCommand(.ISC_READ, NoData, null, null, writer, nl);

        var row: u16 = 0;
        while (row < Device.jedec_dimensions.height()) : (row += 1) {
            try writeIdle(.ISC_READ, writer, nl);
            try writer.print("SDR\t{}\tTDI  (", .{ Device.jedec_dimensions.width() });
            const chars: u16 = @intCast((Device.jedec_dimensions.width() + 3) / 4);
            try writer.writeByteNTimes('0', chars);
            try writer.print("){s}\t\tTDO  (", .{ nl });

            try writeRowHex(file.data, row, writer);
            try writer.print(");{s}", .{ nl });
        }
        try writer.writeAll(nl);
    }

    if (file.usercode) |u| {
        try writeCommand(.ISC_PROGRAM_USERCODE, u32, u, null, writer, nl);
        if (options.verify) {
            try writeCommand(.READ_USERCODE, u32, 0xFFFFFFFF, u, writer, nl);
        }
        try writer.writeAll(nl);
    }

    if (file.security) |g| {
        if (g != 0) {
            try writeCommand(.ISC_PROGRAM_SECURITY, NoData, null, null, writer, nl);
            try writer.writeAll(nl);
        }
    }

    try writeCommand(.ISC_PROGRAM_DONE, NoData, null, null, writer, nl);
    try writeCommand(.ISC_PROGRAM_DONE, NoData, null, null, writer, nl); // not sure why this is done twice...?
    try writeCommand(.ISC_DISABLE, NoData, null, null, writer, nl);
    try writeCommand(.BYPASS, NoData, null, null, writer, nl);
    try writer.print("! {s}{s}", .{ @tagName(JtagCommand.IDCODE), nl });
    try writer.print("SIR\t8\tTDI  ({X:0>2}){s}", .{ @intFromEnum(JtagCommand.IDCODE), nl });
    try writer.print("\t\tTDO  ({X:0>2});{s}", .{ 0x1D, nl });
    try writeCommand(.ISC_DISABLE, NoData, null, null, writer, nl);
    try writeState("RESET", writer, nl);
}

fn writeRowHex(data: jedec.JedecData, row: u16, writer: anytype) !void {
    const chars: u16 = @intCast((data.extents.width() + 3) / 4);
    var col: i32 = chars * 4;
    while (col >= 4) : (col -= 4) {
        var val: u4 = 0;
        comptime var b = 1;
        inline while (b <= 4) : (b += 1) {
            const c = col - b;
            if (c < data.extents.width()) {
                val *= 2;
                val += data.get(Fuse.init(row, @intCast(c)));
            }
        }
        try writer.print("{X:0>1}", .{ val });
    }
}

fn writeHex(comptime T: type, data: T, writer: anytype) !void {
    if (T != NoData) {
        // Ideally we could use std.fmt to print this all at once,
        // but it currently fails when trying to print large numbers:
        // https://github.com/ziglang/zig/issues/1534
        const bits = @bitSizeOf(T);
        const digits = comptime (bits + 3) / 4;

        var d: usize = 0;
        while (d < digits) : (d += 1) {
            const shift: std.math.Log2Int(T) = @intCast(4 * (digits - d - 1));
            const part: u4 = @truncate(data >> shift);
            try writer.print("{X:0>1}", .{ part });
        }
    }
}

fn writeCommand(command: JtagCommand, comptime T: type, tdi_data: ?T, tdo_data: ?T, writer: anytype, nl: []const u8) !void {
    try writer.print("! {s}{s}", .{ @tagName(command), nl });
    try writer.print("SIR\t8\tTDI  ({X:0>2});{s}", .{ @intFromEnum(command), nl });

    if (tdi_data) |tdi| {
        try writer.print("SDR\t{}\tTDI  (", .{ @bitSizeOf(T) });
        try writeHex(T, tdi, writer);

        if (tdo_data) |tdo| {
            try writer.print("){s}\t\tTDO  (", .{ nl });
            try writeHex(T, tdo, writer);
        }

        try writer.print(");{s}", .{ nl });
    }

    switch (command) {
        .ISC_PROGRAM, .ISC_READ => {},
        else => try writeIdle(command, writer, nl),
    }
}

fn writeState(state: []const u8, writer: anytype, nl: []const u8) !void {
    try writer.print("STATE\t{s};{s}", .{ state, nl });
}

fn writeIdle(command: JtagCommand, writer: anytype, nl: []const u8) !void {
    const delay = command.getDelay();
    if (delay.min_ms > 0 and delay.min_clocks > 0) {
        try writer.print("RUNTEST\tIDLE\t{} TCK\t{}.E-3 SEC;{s}", .{ delay.min_clocks, delay.min_ms, nl });
    } else if (delay.min_ms > 0) {
        try writer.print("RUNTEST\tIDLE\t3 TCK\t{}.E-3 SEC;{s}", .{ delay.min_ms, nl });
    } else if (delay.min_clocks > 0) {
        try writer.print("RUNTEST\tIDLE\t{} TCK;{s}", .{ delay.min_clocks, nl });
    }
}
